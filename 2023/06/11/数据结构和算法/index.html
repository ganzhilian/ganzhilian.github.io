<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>数据结构和算法 | LuckyFeng的博客</title><meta name="description" content="数据结构和算法"><meta name="keywords" content="算法"><meta name="author" content="覃烽"><meta name="copyright" content="覃烽"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="数据结构和算法"><meta name="twitter:description" content="数据结构和算法"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="数据结构和算法"><meta property="og:url" content="http://example.com/2023/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><meta property="og:site_name" content="LuckyFeng的博客"><meta property="og:description" content="数据结构和算法"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://example.com/2023/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"><link rel="prev" title="网络" href="http://example.com/2023/06/11/%E7%BD%91%E7%BB%9C/"><link rel="next" title="RocketMq" href="http://example.com/2023/06/11/RocketMq/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'false',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: undefined,
  copy_copyright_js: false,
  ClickShowText: undefined,
  medium_zoom: 'false',
  Snackbar: undefined
  
}</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="header"> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">LuckyFeng的博客</a></span><i class="fa fa-bars fa-fw toggle-menu pull_right close" aria-hidden="true"></i><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 框架</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></span><span class="pull_right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lazyload avatar_img" src="https://s3.bmp.ovh/imgs/2021/08/537218da738c4aaa.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">45</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">17</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 框架</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 其他</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#%E7%AE%97%E6%B3%95"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">基础</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%BC%82%E6%88%96"><span class="toc_mobile_items-number">1.1.1.</span> <span class="toc_mobile_items-text">异或</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%95%B0%E7%BB%84"><span class="toc_mobile_items-number">1.1.2.</span> <span class="toc_mobile_items-text">数组</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E4%BA%8C%E5%88%86"><span class="toc_mobile_items-number">1.1.2.1.</span> <span class="toc_mobile_items-text">二分</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E5%BD%92%E5%B9%B6"><span class="toc_mobile_items-number">1.1.2.2.</span> <span class="toc_mobile_items-text">归并</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc_mobile_items-number">1.1.2.2.1.</span> <span class="toc_mobile_items-text">题目</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc_mobile_items-number">1.1.2.3.</span> <span class="toc_mobile_items-text">堆排序</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc_mobile_items-number">1.1.2.3.1.</span> <span class="toc_mobile_items-text">题目</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">链表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc_mobile_items-number">1.2.1.</span> <span class="toc_mobile_items-text">题目</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E6%A0%91"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">树</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E9%81%8D%E5%8E%86"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">遍历</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc_mobile_items-number">1.3.1.1.</span> <span class="toc_mobile_items-text">前序遍历：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc_mobile_items-number">1.3.1.2.</span> <span class="toc_mobile_items-text">中序遍历：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc_mobile_items-number">1.3.1.3.</span> <span class="toc_mobile_items-text">后续遍历：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E5%AE%BD%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc_mobile_items-number">1.3.1.4.</span> <span class="toc_mobile_items-text">宽度遍历：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="toc_mobile_items-number">1.3.1.5.</span> <span class="toc_mobile_items-text">题目</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%A0%91%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">树问题通解</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">前缀树</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">贪心</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc_mobile_items-number">1.4.1.</span> <span class="toc_mobile_items-text">解题思路</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="toc_mobile_items-number">1.4.2.</span> <span class="toc_mobile_items-text">题目</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E9%80%92%E5%BD%92"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">递归</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">回溯</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">基础提升</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%93%88%E5%B8%8C"><span class="toc_mobile_items-number">1.6.1.</span> <span class="toc_mobile_items-text">哈希</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="toc_mobile_items-number">1.6.1.1.</span> <span class="toc_mobile_items-text">大数据</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E5%B8%83%E9%9A%86"><span class="toc_mobile_items-number">1.6.1.2.</span> <span class="toc_mobile_items-text">布隆</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E5%93%88%E5%B8%8C%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc_mobile_items-number">1.6.1.3.</span> <span class="toc_mobile_items-text">哈希一致性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc_mobile_items-number">1.6.2.</span> <span class="toc_mobile_items-text">并查集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#KMP"><span class="toc_mobile_items-number">1.6.3.</span> <span class="toc_mobile_items-text">KMP</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Manacher"><span class="toc_mobile_items-number">1.6.4.</span> <span class="toc_mobile_items-text">Manacher</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc_mobile_items-number">1.6.5.</span> <span class="toc_mobile_items-text">滑动窗口</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84"><span class="toc_mobile_items-number">1.6.6.</span> <span class="toc_mobile_items-text">单调栈结构</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc_mobile_items-number">1.6.7.</span> <span class="toc_mobile_items-text">动态规划</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="toc_mobile_items-number">1.6.7.1.</span> <span class="toc_mobile_items-text">题目</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="toc_mobile_items-number">1.6.8.</span> <span class="toc_mobile_items-text">有序表</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc_mobile_items-number">1.6.8.1.</span> <span class="toc_mobile_items-text">跳表</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%88%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">异或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">二分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">归并</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.1.2.2.1.</span> <span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">堆排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-1"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">题目</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-2"><span class="toc-number">1.2.1.</span> <span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">前序遍历：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">中序遍历：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">后续遍历：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BD%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%9A"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">宽度遍历：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-3"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%97%AE%E9%A2%98%E9%80%9A%E8%A7%A3"><span class="toc-number">1.3.2.</span> <span class="toc-text">树问题通解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-number">1.3.3.</span> <span class="toc-text">前缀树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">1.4.</span> <span class="toc-text">贪心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF"><span class="toc-number">1.4.1.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-4"><span class="toc-number">1.4.2.</span> <span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">1.5.</span> <span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%BA%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">回溯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87"><span class="toc-number">1.6.</span> <span class="toc-text">基础提升</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C"><span class="toc-number">1.6.1.</span> <span class="toc-text">哈希</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E6%8D%AE"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">大数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">布隆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">哈希一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.6.2.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#KMP"><span class="toc-number">1.6.3.</span> <span class="toc-text">KMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Manacher"><span class="toc-number">1.6.4.</span> <span class="toc-text">Manacher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.6.5.</span> <span class="toc-text">滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.6.</span> <span class="toc-text">单调栈结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.6.7.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE-5"><span class="toc-number">1.6.7.1.</span> <span class="toc-text">题目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.6.8.</span> <span class="toc-text">有序表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8"><span class="toc-number">1.6.8.1.</span> <span class="toc-text">跳表</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">数据结构和算法</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2023-06-11<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2023-06-11</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><div class="post-meta-wordcount"><i class="fa fa-file-word-o post-meta__icon" aria-hidden="true"></i><span>字数总计: </span><span class="word-count">11.3k</span><span class="post-meta__separator">|</span><i class="fa fa-clock-o post-meta__icon" aria-hidden="true"></i><span>阅读时长: 45 分钟</span><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true">       </i><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><blockquote>
<p>学习视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1kQ4y1h7ok/?p=9&amp;spm_id_from=pageDriver&amp;vd_source=dd5d1ef71c78ae671bcb138273ecb421">https://www.bilibili.com/video/BV1kQ4y1h7ok/?p=9&amp;spm_id_from=pageDriver&amp;vd_source=dd5d1ef71c78ae671bcb138273ecb421</a></p>
</blockquote>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h3><blockquote>
<p><strong>与：有0则0，全1为1。异或：相同为0，不同为1。</strong></p>
<p><strong>重要算法：得到一个数在二进制中最右的1所在的位置。a &amp; （ <del>a + 1）其中</del>a为取反</strong></p>
</blockquote>
<p><strong>题1：数组中有一个出现奇数次的数，其他都为出现了偶数次的数，找出奇数次的数</strong></p>
<blockquote>
<p>解题：数组所有值全部异或。</p>
</blockquote>
<p><strong>题1：数组中有两个出现奇数次的数，其他都为出现了偶数次的数，找出奇数次的数</strong></p>
<blockquote>
<p>解题：假设a、b为出现两次的奇数，则数组所有制全部异或上得到的结果肯定为a^b，由于出现的这两个值出现了奇数次，所有a和b在二进制中，有一位肯定是1，才能保证他们不相同，所以找出那一位，再跟数组中的所有值进行比较，这一位中&amp;所有值，当为0时，用一个变量异或上，循环结束，就能找到其中一个值。代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            eor ^= arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//eor: a ^ b</span></span><br><span class="line">        <span class="comment">//rightOne: 最靠右为1的数</span></span><br><span class="line">        <span class="keyword">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> onlyOne = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((rightOne &amp; arr[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                onlyOne ^= arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(onlyOne + <span class="string">&quot;， &quot;</span> + (onlyOne ^ eor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><blockquote>
<p>当一个数组基本有序时，找出其中一个数，可以使用二分查找。（不有序的特殊的情况有时候也可以用）</p>
</blockquote>
<p><strong>在一个有序数组中，找某个数是否存在</strong></p>
<blockquote>
<p>二分查找</p>
</blockquote>
<p><strong>在一个有序数组中，找&gt;=某个数最左侧的位置</strong></p>
<blockquote>
<p>遍历 / 二分</p>
</blockquote>
<p><strong>局部最小值问题</strong></p>
<blockquote>
<p><strong>举例：</strong></p>
<p>{2,9,1,7,6,5,4,3}，N=8，其中2、1和3均为局部最小值，返回任意一个就行。</p>
<blockquote>
<p>对于边界来说，如果nums[0] &lt; nums[1]，则nums[0]是一个局部最小。如果nums[n-1] &lt; nums[n-2]，则nums[n-1]是一个局部最小。<br>对于非边界来说，如果i ∈ [i,n-2] ，并且nums[i] &lt; nums[i+1] &amp;&amp; nums[i] &lt; nums[i-1]，则nums[i]是一个局部最小。</p>
</blockquote>
</blockquote>
<h4 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeGroup</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end || Objects.isNull(arr)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        mergeGroup(arr, start, mid);</span><br><span class="line">        mergeGroup(arr, mid + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">        merge(arr, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start,<span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] newArr = <span class="keyword">new</span> <span class="keyword">int</span>[(end - start) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">                newArr[k++] = arr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                newArr[k++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            newArr[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= end) &#123;</span><br><span class="line">            newArr[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            arr[start + i] = newArr[i];</span><br><span class="line"></span><br><span class="line">        newArr = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><strong>归并延申问题：在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。</strong></p>
<p>比如数组 [1, 3, 4, 2, 5]</p>
<p>1 左边比 1 小的数，没有</p>
<p>3 左边比 3 小的数，1</p>
<p>4 左边比 4 小的数，1、3</p>
<p>2 左边比 2 小的数，1</p>
<p>5 左边比 5 小的数，1、3、2、4</p>
<p>所以小和为 1 + 1 + 3 + 1 + 1 + 3 + 4 + 2 = 16</p>
<p>我们转换一个思路，求每一个数左边比当前小的数，也就等同于求每个数右边比当前大的数的个数</p>
<p>仍然以数组 [1, 3, 4, 2, 5] 举例说明如下：</p>
<p>1 它的右边有 4 个数比它大</p>
<p>3 它的右边有 2 个数比它大</p>
<p>4 它的右边有 1 个数比它大</p>
<p>2 它的右边有 1 个数比它大</p>
<p>5 它的右边没有数比它大</p>
<p>小和为 1 * 4 + 3 * 2 + 4 * 1 + 2 * 1 = 16</p>
<p><strong>所以这个问题当他划分到倒数第二层时，判断这个数是否小于右边的数，小于看看有几个（几个：其实这里创建好的数组空间已经排好序，所以直接乘相减的数就可以了），为了避免出现左11111，mid：2，右：1111333，需要判断左边1大于右边数的时候才能计算出几个数</strong></p>
<p>答案：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mmimo/p/15397049.html">https://www.cnblogs.com/mmimo/p/15397049.html</a></p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>堆排序的结构相当于一棵完全二叉树</strong>，一个节点只有左右两颗子树或以下，大顶堆：代表这个数的节点（从根开始）永远比他的左右子节点大，小顶堆相反，所以我们可以利用大顶堆的特性对数据进行排序，需要先对数组进行初始化成大根堆，<br>每插入一个元素都需要跟父节点进行比较，是否需要交换元素，已达到大顶堆的目的。之后排序，因为根节点作为完全二叉树的最大值，可以将这个值放入到数组的末尾，将数组的末尾的值放入到大根堆得位置也就是0下标，当heapSize小于0时说明排序结束。</p>
<p><strong>优先级队列采用的就是堆结构，底层是数组，扩容时按两倍2的n次幂，但不支持手动改写堆结构的某个值，不提供这种操作，只允许放入一个数，拿出一个数，所以手动写的堆，能给我们处理这种情况</strong></p>
<p><strong>堆排序有两个重要方法：① 插入时形成大顶堆的一个初始化heapInsert，② 利用左右节点，父节点重新形成大顶堆heapify。</strong></p>
<p><strong>重要知识：找父节点：index - 1 / 2，找左节点：2 * index + 1，找右节点2 * index + 2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">heapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125; </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr==<span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;arr.length;i++)&#123;	<span class="comment">// O(N)</span></span><br><span class="line">            heapInsert(arr, i);		<span class="comment">// O(logN)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> heapSize = arr.length;</span><br><span class="line">        swap(arr, <span class="number">0</span>, --heapSize);</span><br><span class="line">        <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;	<span class="comment">// O(N)</span></span><br><span class="line">            heapify(arr,<span class="number">0</span>, heapSize);	<span class="comment">// O(logN)</span></span><br><span class="line">            swap(arr, <span class="number">0</span>, --heapSize);	<span class="comment">// O(1)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这是关于堆的上浮与下沉的代码，我们在之前的文章已经介绍过</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, index, (index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; heapSize) &#123;<span class="comment">// 表明此时有孩子节点</span></span><br><span class="line">            <span class="comment">// 找出左孩子和右孩子中更大的值，</span></span><br><span class="line">            <span class="comment">// 如果右孩子存在且右孩子的值大于左孩子，就返回右孩子的下标，否则返回左孩子的下标</span></span><br><span class="line">            <span class="keyword">int</span> largest = left + <span class="number">1</span> &lt; heapSize &amp;&amp; arr[left + <span class="number">1</span>] &gt; arr[left] ? left + <span class="number">1</span> : left;</span><br><span class="line">            <span class="comment">// 将孩子中更大的那一个和父亲比较，如果比父亲大，则把下标给 largest</span></span><br><span class="line">            largest = arr[largest] &gt; arr[index] ? largest : index;</span><br><span class="line">            <span class="comment">// 如果孩子节点都没父亲大，则结束比较</span></span><br><span class="line">            <span class="keyword">if</span> (largest == index) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, index, largest);</span><br><span class="line">            <span class="comment">// 记录 largest ，用于下一次循环比较</span></span><br><span class="line">            index = largest;</span><br><span class="line">            left = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充一句：PriorityQueue大小根堆实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认为小根堆</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; que = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line"><span class="comment">//大根堆需要PriorityQueue实现比较器</span></span><br><span class="line">A=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO 自动生成的方法存根</span></span><br><span class="line">				<span class="keyword">return</span> o2-o1;</span><br><span class="line">			&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h5><p><strong>1、一个数据流中，随时可以取得中位数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解题思路：利用大根堆和小根堆， 当前元素需要跟大根堆的堆顶进行比较，是否大于大根堆堆顶，大于则放入到小根堆中，小于放入到大根堆中，当大根堆和小根堆的节点数的差的绝对值等于2时，将多的那一方的值，出列，放入到较小的那一方。结束时即可得到中位数，如果数组为双数，两队列出队相加/2，如果单数，寻找最多的那一方。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">middleNum</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; little = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//创建大根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; big = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        big.add(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> bigNum = big.poll();</span><br><span class="line">            <span class="comment">//大于大根堆的顶点放入到小根堆，小于放入到小根堆</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; bigNum) &#123;</span><br><span class="line">                big.add(bigNum);</span><br><span class="line">                little.add(arr[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                big.add(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//多的一方放入到少的一方，达到平衡</span></span><br><span class="line">            <span class="keyword">if</span> (big.size() - little.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                little.add(big.poll());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( little.size() - big.size() == <span class="number">2</span>) &#123;</span><br><span class="line">                big.add(little.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr.length % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (big.poll() + little.poll()) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> big.size() &gt; little.size() ? big.poll() : little.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>题外话：如果想让某个下标位置不动，可以让她自己与自己交换，i位置继续往前走。</p>
</blockquote>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p><strong>一般链表问题可用快慢指针或者哈希表解决</strong>或者被暴力，<strong>链表最重要的是保存下一个next的链表</strong></p>
<p>反转链表</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/15/077d244c3b284256.png" class="lazyload"></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><strong>回文链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法1：栈</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stackNode = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode pushNode  = head,isPalindromeNode = head;</span><br><span class="line">        <span class="keyword">while</span> (pushNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stackNode.push(pushNode);</span><br><span class="line">            pushNode = pushNode.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (isPalindromeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindromeNode.val != stackNode.pop().val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                isPalindromeNode = isPalindromeNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解法2：使用快慢指针+链表反转，慢指针前进一步，快指针前进两步，当快指针结束时，为空时，则说明慢指针到达了链表的中见下表，这时候反转慢指针往后得下标。之后头节点和反转后的头节点进行比较即可。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="comment">//通过快慢指针找到中点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果fast不为空，说明链表的长度是奇数个</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转后半部分链表</span></span><br><span class="line">    slow = reverse(slow);</span><br><span class="line"></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//然后比较，判断节点值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (fast.val != slow.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>提供一个数和链表，进行排序，小于这个数得排左，等于排中间，大于排右边</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一：放入到Node数组中，在进行排序。</span></span><br><span class="line"><span class="comment">//解法二：提供6个临时节点，两个节点为小于该数得头节点和尾节点，两个节点为等于该数得头节点和尾节点，两个节点为大于该数得头节点和尾节点，第一个为初始节点，设置为小于的头结点，之后的数进行比较，之后放入到对应得节点，之后将这些节点进行头尾相连。</span></span><br></pre></td></tr></table></figure>

<p><strong>循环或者不循环单链表，找出可能循环的第一个节点</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可用HashSet或HashTable。重复则说明找到第一个节点</span></span><br><span class="line"><span class="comment">//使用快慢指针，慢走一步，快走两步，最后两个节点始终会相遇，然后两个节点再往前走一步就是第一个循环节点（结论）</span></span><br></pre></td></tr></table></figure>

<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p><strong>树的遍历分为深度遍历和广度遍历。深度遍历分为：前序遍历，中序遍历，后续遍历</strong></p>
<h4 id="前序遍历："><a href="#前序遍历：" class="headerlink" title="前序遍历："></a>前序遍历：</h4><p>**头左右。先从头节点触发，先遍历左边，在遍历有右边。可以利用栈，每读到一个节点压栈，之后先压右节点再压左节点，读出来就是前序遍历。 **</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrderRecur</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     	System.out.println(node.val);</span><br><span class="line">        preOrderRecur(node.left);</span><br><span class="line">        preOrderRecur(node.right);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//非递归写法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stackTree = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">     	stackTree.push(node);</span><br><span class="line">        <span class="keyword">while</span> (!stackTree.isEmpty()) &#123;</span><br><span class="line">            node = stackTree.pop();</span><br><span class="line">            System.out.println(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stackTree.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stackTree.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="中序遍历："><a href="#中序遍历：" class="headerlink" title="中序遍历："></a>中序遍历：</h4><p><strong>如果左孩子，先把左孩子全部放入到栈中，之后出栈，再把右孩子放入到栈中</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stackTree = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!stackTree.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stackTree.push(node);</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stackTree.pop();</span><br><span class="line">                System.out.println(node.val);</span><br><span class="line">                node = node.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="后续遍历："><a href="#后续遍历：" class="headerlink" title="后续遍历："></a>后续遍历：</h4><p><strong>左头右。利用两个栈，一个读栈，一个保存栈。从根节点触发，把根节点放入到读栈中，然后pop的同时，把节点放入到保存栈中，在判断这个节点的左右节点是否存在，如果都存在，先放左再放右到读栈中，之后读栈读出的数据放入到保存栈中。当读栈为空时，说明结束，将保存栈中的数据读出即可得到后序遍历结果。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastOrder</span><span class="params">(TreeNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; readTree = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; saveTree = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        readTree.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!readTree.isEmpty()) &#123;</span><br><span class="line">            head = readTree.pop();</span><br><span class="line">            saveTree.push(head);</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                readTree.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                readTree.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!saveTree.isEmpty()) &#123;</span><br><span class="line">            System.out.println(saveTree.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="宽度遍历："><a href="#宽度遍历：" class="headerlink" title="宽度遍历："></a>宽度遍历：</h4><p><strong>采用队列（求每一行树叶的个数或者）</strong></p>
<h4 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h4><p><strong>如何判断一棵树为搜索二叉树：使用中序遍历</strong></p>
<p>搜索二叉树特点：左节点比根节点小，根节点比右节点小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一：利用一个临时的Node节点，minNode值为Integer最大的，利用递归的中序遍历，当输出左节点时，进行处理，跟值minNode进行比较，如果小于说明搜索二叉树条件成立，minNode.val = 当前节点的值，再继续跟跟根节点进行比较</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer preValue = Integer.MAX_VALUE;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">inOrderRecur</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">boolean</span> b = inOrderRecur(node.left);</span><br><span class="line">        <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="keyword">if</span> (preValue &lt;= node.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         preValue = node.val;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> inOrderRecur(node.right);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解法二：临时的Node的链表，每一次进行递归的中序遍历，就把值放入到List中，然后再判断链表中的值是否升序。如下图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解法三：非递归中序，其实跟递归差不多。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>解法二：</strong></p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/17/8ea8c4b4abe41811.png" class="lazyload"></p>
<p><strong>解法三：</strong></p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/17/ea315735f2a2ac6d.png" class="lazyload"></p>
<p><strong>判断完全二叉树：宽度遍历</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个条件：① 有右没左返回false，② 有一个左节点，下面一层的节点皆为叶子节点才为完全二叉树。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>判断自平衡二叉树：递归</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//判断左子树是否平衡且高度差小于等于1，右子树是否平衡且高度差小于等于1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/17/fad46b829a6c59ad.png" class="lazyload"></p>
<h3 id="树问题通解"><a href="#树问题通解" class="headerlink" title="树问题通解"></a>树问题通解</h3><p><strong>每个数的左子树和右子树都必须返回最大最小值和是否平衡</strong></p>
<p><strong>树的序列化和反序列化：将一棵树转化为字符串，字符串在转为树，先序遍历，遇到节点放入到字符串中，并拼接_，遇到空，拼接#_，之后解字符串时，将字符串中的_分割成字符串数组，然后一个个便利成树</strong></p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/17/a38ba6851fe1687f.png" class="lazyload"></p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/17/41da28d6e50df176.png" class="lazyload"></p>
<h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><p><img data-src="https://s3.bmp.ovh/imgs/2023/03/17/deaaf587c8ef9017.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pass;<span class="comment">//有几条经过了</span></span><br><span class="line">        <span class="keyword">int</span> end; <span class="comment">//有几条结尾了</span></span><br><span class="line">        <span class="keyword">public</span> TrieNode[] nexts;<span class="comment">//Hash&lt;Char, Node&gt; nexts;当无法26个字母无法满足时，可用这个</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            pass = <span class="number">0</span>;</span><br><span class="line">            end = <span class="number">0</span>;</span><br><span class="line">            nexts = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">     TrieNode root;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">     &#125;</span><br><span class="line">	</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">        TrieNode trieNode = root;</span><br><span class="line">        trieNode.pass++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (trieNode.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                trieNode.nexts[index] = <span class="keyword">new</span> TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            trieNode.pass++;</span><br><span class="line">            trieNode = trieNode.nexts[index];</span><br><span class="line">        &#125;</span><br><span class="line">        trieNode.end++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (search(word) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">         TrieNode trieNode = root;</span><br><span class="line">         trieNode.pass--;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">             <span class="keyword">int</span> index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">             <span class="keyword">if</span> (--trieNode.nexts[index].pass == <span class="number">0</span>) &#123;</span><br><span class="line">                 trieNode.nexts[index] = <span class="keyword">null</span>;</span><br><span class="line">                 <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             trieNode = trieNode.nexts[index];</span><br><span class="line">         &#125;</span><br><span class="line">         trieNode.end++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//加入过几次</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (word == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">char</span>[] chs = word.toCharArray();</span><br><span class="line">         TrieNode trieNode = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = chs[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (trieNode.nexts[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            trieNode = trieNode.nexts[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> trieNode.end;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/17/6a18f499a6fcea17.png" class="lazyload"></p>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>基本解法：1.根据某标准建立一个比较器来排序，2.根据某标准建立一个比较器组成堆（有时候需要使用大小根堆结合）</strong>贪心算法每道题的解法不一，最终还是需要多练。</p>
<h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><p><strong>1、一些项目要占用一个会议室宣讲。给你每一个项目开始的时间和结束的时间（给你一个数组，里面是一个个具体的项目），你来安排宣讲的日程，要求会议室进行的宣讲的场次最多。返回这个最多的宣讲场次。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比较器+排序，</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Program</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Program</span>&gt;</span>&#123;</span><br><span class="line">     <span class="keyword">int</span> start;</span><br><span class="line">     <span class="keyword">int</span> end;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Program</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.start = start;</span><br><span class="line">         <span class="keyword">this</span>.end = end;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Program o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.start - o.start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bestArrange</span><span class="params">(Program[] program, <span class="keyword">int</span> timePoint)</span> </span>&#123;</span><br><span class="line">     Arrays.sort(program);</span><br><span class="line">     <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; program.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (program[i].start &gt;= timePoint) &#123;</span><br><span class="line">             result++;</span><br><span class="line">             timePoint = program[i].end;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>2、给定一个数组让你切金条，怎么切花费最小。arr = {10,20,30}，一共60，如果按10，50切，则花费60，50再按20和30切，则花费50，一共花费110。但如果按30，30切，则花费60，30再按10和20切，则花费30，一共花费90。最优解</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//解答思路：利用小顶堆（优先队列），就会拿到每次切最小的值。达到最优解</span><br><span class="line">public static int bestCutGold(int arr[]) &#123;</span><br><span class="line">     PriorityQueue&lt;Integer&gt; que = new PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        for (int i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">            que.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        int cur = 0;</span><br><span class="line">        while (!que.isEmpty()) &#123;</span><br><span class="line">            cur = que.poll() + que.poll();</span><br><span class="line">            sum += cur;</span><br><span class="line">            que.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、leetCode 2279题：</strong><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/">https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumBags</span><span class="params">(<span class="keyword">int</span>[] capacity, <span class="keyword">int</span>[] rocks, <span class="keyword">int</span> additionalRocks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用小根堆贪心。</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; rockQue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[rocks.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rocks.length; i++) &#123;</span><br><span class="line">            <span class="comment">//计算得到每个背包还剩多少容量（其实不用数组也可以，直接存数据。）</span></span><br><span class="line">            arr[i] = capacity[i] - rocks[i];</span><br><span class="line">            rockQue.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计满背包次数</span></span><br><span class="line">        <span class="keyword">int</span> fullCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!rockQue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> remainCap = rockQue.poll();</span><br><span class="line">            <span class="comment">//代表当前背包满了，比如capacity：1，rocks：1</span></span><br><span class="line">            <span class="keyword">if</span> (remainCap &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                fullCount++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没满，尝试填满背包</span></span><br><span class="line">            additionalRocks = additionalRocks - remainCap; </span><br><span class="line">            <span class="keyword">if</span> (additionalRocks &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                fullCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//因为是小根堆，当无法满足条件时，必定后面的值不会满足，直接退出返回即可</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fullCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>4、</strong></p>
<p><strong>输入：</strong></p>
<p>正数数组costs</p>
<p>正数数组profits</p>
<p>正数k</p>
<p>正数m</p>
<p><strong>含义：</strong></p>
<p>costs[i]表示i号项目的花费</p>
<p>profits[i]表示i号项目在扣除花费之后还能挣到的钱(利润)</p>
<p>k表示你只能串行的最多做k个项目</p>
<p>m表示你初始的资金</p>
<p>说明： 你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。</p>
<p>比如costs[3,2,1,15], profits[1,2,3,1]；m=1，初始资金1，那我可以做costs为1的项目，获得资金为profits的3，初始资金变为4，接着找，直到初始资金无法满足花费时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这道题与上一题有异曲同工之妙</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code05_IPO</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 每个项目由花费和收益两部分组成</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">int</span> c;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.p = p;</span><br><span class="line">         <span class="keyword">this</span>.c = c;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义项目最小花费的比较器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MinCostComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> o1.c - o2.c;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义项目最大收益的比较器</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxProfitComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Node o1, Node o2)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> o2.p - o1.p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主方法</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMaximizedCapital</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> W, <span class="keyword">int</span>[] Profits, <span class="keyword">int</span>[] Costs)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 根据花费和收益数组创建对应项目数组</span></span><br><span class="line">      ArrayList&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Profits.length; i++) &#123;</span><br><span class="line">         nodes.add(<span class="keyword">new</span> Node(Profits[i], Costs[i]));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建小根堆（花费最小）和大根堆（收益最大）</span></span><br><span class="line">      PriorityQueue&lt;Node&gt; minCostsHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MinCostComparator());</span><br><span class="line">      PriorityQueue&lt;Node&gt; maxProfitsHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> MaxProfitComparator());</span><br><span class="line">      <span class="comment">// 将所有项目放入小根堆</span></span><br><span class="line">      minCostsHeap.addAll(nodes);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">         <span class="comment">// 如果小根堆不为空并且其元素小于等于初始资金，将其解锁弹出放入大根堆中。</span></span><br><span class="line">         <span class="keyword">while</span>(!minCostsHeap.isEmpty() &amp;&amp; minCostsHeap.peek().c &lt;= W)&#123;</span><br><span class="line">            maxProfitsHeap.add(minCostsHeap.poll());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 没有可以做的项目，返回W</span></span><br><span class="line">         <span class="keyword">if</span>(maxProfitsHeap.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> W;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 将选择的项目收益加入初始资金中，更新初始资金</span></span><br><span class="line">         W += maxProfitsHeap.poll().p;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> W;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] Profits = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span>[] Costs = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">      <span class="keyword">int</span> result = findMaximizedCapital(<span class="number">4</span>, <span class="number">2</span>, Profits, Costs);</span><br><span class="line">      System.out.println(<span class="string">&quot;完成项目最终获得的最大资金为：&quot;</span> + result);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong>破解动态规划的关键，特别是递归问题。需要先暴力破解好，然后再用动态规划</strong></p>
<p><strong>题目</strong></p>
<p><strong>1、汉诺塔问题，三个柱子，左中右，有三个圆盘，从小到大，不能从大到小插入到柱子中。如果有n个圆柱或者n个圆盘如何实现。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归：我只需要最后一个圆盘以外其他圆盘，都放入到其他柱子当中，保证最后一个圆盘放入到指定圆柱当中即可，直到圆盘数为0.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/19/deb1e467c0620f68.png" class="lazyload"></p>
<p><strong>2、求一个字符串的所有子序列。abc：a，b，c，ab，ac，bc，abc</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归，一个字符只有要和不要两个过程，要加入新的集合，不要加入到不要的集合。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allSonSer</span><span class="params">(<span class="keyword">char</span>[] arr, <span class="keyword">int</span> i, List&lt;Character&gt; chars)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(i == arr.length) &#123;</span><br><span class="line">         System.out.println(chars);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">        List list1 = newList(chars);</span><br><span class="line">        list1.add(arr[i]);</span><br><span class="line">     allSonSer(arr, i + <span class="number">1</span>, list1);</span><br><span class="line">        List list2 = newList(chars);</span><br><span class="line">     allSonSer(arr, i + <span class="number">1</span>, list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List <span class="title">newList</span><span class="params">(List&lt;Character&gt; chs)</span> </span>&#123;</span><br><span class="line">     List&lt;Character&gt; chars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.size(); i++) &#123;</span><br><span class="line">         chars.add(chs.get(i));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> chars;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>3、给你一个栈，逆序栈中的元素，不采用其他数据结构，只能递归</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//肯定需要一个函数f把栈底的值返回出来，然后再把所有返回出来的数，重新放入到栈中。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img alt="1679214337803" data-src="/2023/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/Users\qinfeng\AppData\Roaming\Typora\typora-user-images\1679214337803.png" class="lazyload"></p>
<p>f函数过程</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/19/f43f5eee062895f8.png" class="lazyload"></p>
<p>reverse过程</p>
<p><img alt="1679214291752" data-src="/2023/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/Users\qinfeng\AppData\Roaming\Typora\typora-user-images\1679214291752.png" class="lazyload"></p>
<p><strong>4、规定1和A对应、2和B对应、3和C对应…那么一个数字字符串比如“111”就可以转化为：‘AAA“、 “KA“和“AK”。给定一个只有数字字符组成的字符串str，返回有多少种转化结果</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从左到右考虑，如果i作为单独的字母，则i + 1到length的长度还剩多少种情况。如果i不作为单独的字母，则有要分开讨论，当i对应为1时，分为单独字母，或者与i + 1合成一个字母，则需要考虑i + 2到length的情况，如果为2时，i可以为一个字母，或者与i + 1结合成字母，但需要考虑小于等于26的情形，则需要考虑i + 2到length的情况</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/19/8e986c1894fd70d9.png" class="lazyload"></p>
<p><strong>5、给定两个长度都为N的数组weights和values，weights[i]和values[i] 分别代表i号物品的重量和价值。 给定一个正数bag，表示一个载重bag的袋子，装载的物品不能超过这个重量。返回能装下最多的价值是多少？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法一：要么要要么不要，考虑这两种情况，达到最优。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBagValue</span><span class="params">(<span class="keyword">int</span>[] weights, <span class="keyword">int</span>[] values,<span class="keyword">int</span> i, <span class="keyword">int</span> bagWeight, <span class="keyword">int</span> initWeight)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (initWeight &gt; bagWeight) &#123;</span><br><span class="line">         <span class="comment">//先前拿到的，要减回去</span></span><br><span class="line">         <span class="keyword">return</span> -values[i - <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (i == weights.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//要或者不要</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(values[i] + getBagValue(weights, values,i + <span class="number">1</span>, bagWeight, initWeight + weights[i]) , getBagValue(weights, values,i + <span class="number">1</span>, bagWeight, initWeight));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法二：</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/19/17343b78d521f617.png" class="lazyload"></p>
<h3 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h3><p><strong>组合</strong></p>
<p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p>
<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, k = 2</span><br><span class="line">输出：</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https://leetcode.cn/problems/combinations/solution/dai-ma-sui-xiang-lu-dai-ni-xue-tou-hui-s-0uql/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combine(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        combineHelper(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combineHelper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> startIndex)</span></span>&#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k)&#123;</span><br><span class="line">            result.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            path.add(i);</span><br><span class="line">            combineHelper(n, k, i + <span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="基础提升"><a href="#基础提升" class="headerlink" title="基础提升"></a>基础提升</h2><h3 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h3><h4 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h4><p><img data-src="https://s3.bmp.ovh/imgs/2023/03/23/c712cf23330e2145.png" class="lazyload"></p>
<blockquote>
<p>详解可到《大数据问题》篇章学习</p>
<p>32 位无符号整数的范围是 [0,4294967295]，现在有一个正好包含 40 亿个无符号整数的文件，所以在整个范围中必然有未出现过的数。可使用的内存有限，怎么找到所有未出现过的数？</p>
<p>我们申请一个长度为<br>−1 的 bit 类型的位数组, 位数组上的每个位置只可以表示 0 或 1 状态。首先遍历这 40 亿个无符号数，例如，遇到 1000，就把 bitArr[1000] 设置为 1，这样，遍历第二遍的时候所有值为 0 的下标就是未出现的数。</p>
<p>简单算一下这种做法需要多大的内存空间：</p>
<p>8 个 bit 为 1B，所以长度为 42 9496 7295 的 bit 类型的数组占用 5 3687 0911 B 的空间，按照 1MB = 1024 * 1024 B 来算，那就是大概 500 多 MB 的空间大小</p>
<p>用一个整形数组，记录每个区间的数的数量，当一个区间的范围内小于这个范围，则代表存在未出现的数，然后去这个区间进行查找，再用bitmap的数量就小了很多。</p>
<p>详解：<a target="_blank" rel="noopener" href="https://leetcode.cn/circle/discuss/7FYF5C/">https://leetcode.cn/circle/discuss/7FYF5C/</a></p>
</blockquote>
<h4 id="布隆"><a href="#布隆" class="headerlink" title="布隆"></a>布隆</h4><blockquote>
<p>解决黑名单、爬虫黑名单、去重问题。</p>
</blockquote>
<p><strong>比如有很多黑名单用户，100亿。不希望这些黑名单访问到我们的公司。也就是100亿个url，限制一下长度64字节。如果用HashSet，640G内存爆炸。如果用硬盘，每个用户都用去查硬盘数据，用户体验效率极差。所以布隆过滤器出来了，但是有稍许错误率（黑变白不会出现，白变黑布隆会出现这种小问题）。</strong></p>
<p><strong>底层：通过位图进行运算</strong></p>
<blockquote>
<p>正常来说我们可以用int类型或者long类型来表示某个元素在这个下标下的状态（0或者1），但是这样未免太消耗内存，比如int占四个字节，假设数组大小100，一个字节8个bit（比特）则一共需要3200bit ，在布隆过滤器中，它是用bit数组代表某一位的状态，假设bit数组100，每一位只占1个bit，实际使用空间很小。</p>
<p><strong>所以他是通过位运算，压缩时间和空间，查询到该位的一个状态，达到一个最大的使用效率。</strong></p>
</blockquote>
<p><strong>黑名单问题：</strong>当有URL进入时，会把这个URL通过哈希函数（可以多个，但是需要查多个位图位置下标是否为黑），计算哈希值，计算得到的哈希值跟长度m进行模运算，得到一个下标位置，然后将这个下标位置涂黑，代表是黑名单。查的时候就去位图中拿状态。（白变黑问题：如果长度太小，则很多地方都变黑，白的再进来也是黑）。</p>
<h4 id="哈希一致性"><a href="#哈希一致性" class="headerlink" title="哈希一致性"></a>哈希一致性</h4><blockquote>
<p>正常业务逻辑是：发起请求，打到数据库，查询数据，如果是单数据库，很容易。但是如果是多数据库时不一定了。比如3台数据，发请求时，计算得到哈希值，然后模上3，得到在哪台机器上查找。（注意：这里要模的哈希值必须尽可能取不唯一的数），当流量增大时，我们需要增大数据库，会导致，数据需要迁移，比如4台数据库，之前的数据就需要模上4重新分配数据库，否则查不到。</p>
</blockquote>
<p>引出：<strong>哈希环</strong>。每个数据库服务器的Mac地址几乎唯一的，然后通过这个Mac地址计算出哈希值，放入到哈希环里面，假设哈希环用MD5实现。假设m1，m2，m3三台数据库，当有请求时，计算出哈希值，然后顺时针找到哪个服务器离我最近，就去那里找。好处：当有新的数据库时，数据迁移的代价就变得非常低，比如新服务器在m2和m3之间，则只需要把m3的数据部分迁移到m4即可，不需要像之前的全量移动。下的时候就找最久的机器。<strong>问题：</strong>① 服务器过少时，不一定能保证环的均分。② 当有新机器时，就马上不平衡了，比如m1,m2负责三分之一，当有新机器时，m3和m4就负责六分之一了，负载不均衡。<strong>解决办法：</strong>虚拟节点技术</p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>没学</p>
<blockquote>
<p>一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个矩阵中有多少个岛？</p>
</blockquote>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/20/3f7c55f0bcb5afd6.png" class="lazyload"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//感染：当有1时，将1变为2，然后查找上下左右是否为1，然后将其变为2，每次遇到1时就代表有一个岛。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">e08CountIslands</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countIslands</span><span class="params">(<span class="keyword">int</span>[][] m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="keyword">null</span> || m[<span class="number">0</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> N = m.length;</span><br><span class="line">        <span class="keyword">int</span> M = m[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    res++;</span><br><span class="line">                    infect(m, i, j, N, M);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">infect</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> N, <span class="keyword">int</span> M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= N || j &lt; <span class="number">0</span> || j &gt;= M || m[i][j] != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m[i][j] = <span class="number">2</span>;</span><br><span class="line">        infect(m, i - <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i + <span class="number">1</span>, j, N, M);</span><br><span class="line">        infect(m, i, j - <span class="number">1</span>, N, M);</span><br><span class="line">        infect(m, i, j + <span class="number">1</span>, N, M);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] m1 = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#125;;</span><br><span class="line">        System.out.println(countIslands(m1)); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] m2 = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#125;;</span><br><span class="line">        System.out.println(countIslands(m2)); <span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>没学</p>
<p>求：str2 在 str1 中是否存在，如果存在，返回第一次出现的位置，如果没有则返回 -1</p>
<h3 id="Manacher"><a href="#Manacher" class="headerlink" title="Manacher"></a>Manacher</h3><p>求一个字符串最长的子序列</p>
<blockquote>
<p>传统写法优化：每个字符前后加一个特殊字符，然后统计每个字符的最长子序列/2</p>
</blockquote>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/21/29c4b89a928cbb14.png" class="lazyload"></p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><blockquote>
<p>主要有双指针 + 哈希表构成，</p>
</blockquote>
<p><strong>最小覆盖子串</strong></p>
<p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br><span class="line">解释：最小覆盖子串 &quot;BANC&quot; 包含来自字符串 t 的 &#x27;A&#x27;、&#x27;B&#x27; 和 &#x27;C&#x27;。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原文：https://leetcode.cn/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeetCode_76</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//首先创建的是need数组表示每个字符在t中需要的数量，用ASCII码来保存</span></span><br><span class="line">            <span class="comment">//加入need[76] = 2，表明ASCII码为76的这个字符在目标字符串t中需要两个，如果是负数表明当前字符串在窗口中是多余的，需要过滤掉</span></span><br><span class="line">            <span class="keyword">int</span>[] need = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">            <span class="comment">//按照字符串t的内容向need中添加元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">                need[t.charAt(i)]++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        l: 滑动窗口左边界</span></span><br><span class="line"><span class="comment">        r: 滑动窗口右边界</span></span><br><span class="line"><span class="comment">        size: 窗口的长度</span></span><br><span class="line"><span class="comment">        count: 当次遍历中还需要几个字符才能够满足包含t中所有字符的条件，最大也就是t的长度</span></span><br><span class="line"><span class="comment">        start: 如果有效更新滑动窗口，记录这个窗口的起始位置，方便后续找子串用</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, size = Integer.MAX_VALUE, count = t.length(), start = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//循环条件右边界不超过s的长度</span></span><br><span class="line">            <span class="keyword">while</span> (r &lt; s.length()) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = s.charAt(r);</span><br><span class="line">                <span class="comment">//表示t中包含当前遍历到的这个c字符，更新目前所需要的count数大小，应该减少一个</span></span><br><span class="line">                <span class="keyword">if</span> (need[c] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//无论这个字符是否包含在t中，need[]数组中对应那个字符的计数都减少1，利用正负区分这个字符是多余的还是有用的</span></span><br><span class="line">                need[c]--;</span><br><span class="line">                <span class="comment">//count==0说明当前的窗口已经满足了包含t所需所有字符的条件</span></span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果左边界这个字符对应的值在need[]数组中小于0，说明他是一个多余元素，不包含在t内</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; need[s.charAt(l)] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//在need[]数组中维护更新这个值，增加1</span></span><br><span class="line">                        need[s.charAt(l)]++;</span><br><span class="line">                        <span class="comment">//左边界向右移，过滤掉这个元素</span></span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果当前的这个窗口值比之前维护的窗口值更小，需要进行更新</span></span><br><span class="line">                    <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; size) &#123;</span><br><span class="line">                        <span class="comment">//更新窗口值</span></span><br><span class="line">                        size = r - l + <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//更新窗口起始位置，方便之后找到这个位置返回结果</span></span><br><span class="line">                        start = l;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//先将l位置的字符计数重新加1</span></span><br><span class="line">                    need[s.charAt(l)]++;</span><br><span class="line">                    <span class="comment">//重新维护左边界值和当前所需字符的值count</span></span><br><span class="line">                    l++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//右移边界，开始下一次循环</span></span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> size == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h3><p>没学</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><blockquote>
<p>不一定要在返回</p>
</blockquote>
<blockquote>
<p>动态规划问题基本需要从递归方式一步步优化过来，也就是说当解出递归时，可以跟递归的规律进行改良，第一种就是记忆化搜索，<strong>用一维数组或者二维数组保存递归重复的数据</strong>，第二种就是根据记忆化搜索得出来的一维数组或者二维数组，再根据其递归代码规律，进一步优化成动态规划。<strong>记住：当递归方法的参数是多个有变时，则优化的数组就要变成多维的，比如递归有变参数为1，则记忆化搜和动态规划则需要一维数组</strong></p>
</blockquote>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/26/85cb0b98a7dbc056.png" class="lazyload"></p>
<h4 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h4><p><strong>题目一</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">假设有排成一行的N个位置，记为：1~N，N一定大于或等于2</span></span><br><span class="line"><span class="comment">开始时机器人在其中的M位置上(M一定是1~N中的一个)</span></span><br><span class="line"><span class="comment">如果机器人来到1的位置，那么下一步只能往右来到2的位置</span></span><br><span class="line"><span class="comment">如果机器人来到N的位置，那么下一步只能往左来到N-1的位置</span></span><br><span class="line"><span class="comment">如果机器人来到中间位置，那么下一步可以往左走或者往右走</span></span><br><span class="line"><span class="comment">规定机器人开始在M位置，必须走K步，最终能来到E位置(E也是1~N中的一个)的方法有多少种</span></span><br><span class="line"><span class="comment">给定四个参数 N、M、K、E,返回方法数。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">N = 7</span></span><br><span class="line"><span class="comment">M = 3</span></span><br><span class="line"><span class="comment">E = 2</span></span><br><span class="line"><span class="comment">K = 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1  2  3  4  5  6  7</span></span><br><span class="line"><span class="comment">   尾 起 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 3 &gt; 2 &gt; 3 &gt; 2</span></span><br><span class="line"><span class="comment">2. 3 &gt; 2 &gt; 1 &gt; 2</span></span><br><span class="line"><span class="comment">3. 3 &gt; 4 &gt; 3 &gt; 2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回：3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//法一：递归</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">robot</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> K, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无步数可走</span></span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cur == E ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个if的边界条件, 1时往右走，N时往左走</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">        robot(N, E, K - <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">        robot(N, E, K - <span class="number">1</span>, N - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计左右两边的次数</span></span><br><span class="line">    <span class="keyword">return</span> robot(N, E, K - <span class="number">1</span>, cur - <span class="number">1</span>) + robot(N, E, K - <span class="number">1</span>, cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法二：记忆化搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">robotMem</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> K, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[K + <span class="number">1</span>][N + <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= K; i++) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= N; j++) &#123;</span><br><span class="line">              dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> robot2(N, E, K, cur, dp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">robot2</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> E, <span class="keyword">int</span> K, <span class="keyword">int</span> cur, <span class="keyword">int</span>[][] dp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//命中缓存，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (dp[K][cur] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[K][cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//无步数可走</span></span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line">        dp[K][cur] = cur == E ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> dp[K][cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个if的边界条件, 1时往右走，N时往左走</span></span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="number">1</span>) &#123;</span><br><span class="line">        dp[K][cur] = robot(N, E, K - <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == N) &#123;</span><br><span class="line">        dp[K][cur] = robot(N, E, K - <span class="number">1</span>, N - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dp[K][cur] = robot(N, E, K - <span class="number">1</span>, cur - <span class="number">1</span>) + robot(N, E, K - <span class="number">1</span>, cur + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计左右两边的次数</span></span><br><span class="line">    <span class="keyword">return</span> dp[K][cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="comment">//因为是从1到N，所以有N + 1个列，1到E，E + 1行</span></span><br><span class="line">N = <span class="number">7</span></span><br><span class="line">E = <span class="number">2</span></span><br><span class="line">K = <span class="number">4</span></span><br><span class="line">(K,cur) = (<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="number">0</span> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span> cur</span><br><span class="line"><span class="number">0</span> * <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>	</span><br><span class="line"><span class="number">1</span> * <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span> * <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">2</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line"><span class="number">3</span> * <span class="number">1</span>  <span class="number">0</span>  <span class="number">3</span>  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line"><span class="number">4</span> * <span class="number">0</span>  ?  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">K</span><br><span class="line">根据其递归的规律：① 当  K == <span class="number">0</span>时，并且cur == N时，返回<span class="number">1</span>，则(<span class="number">0</span>,<span class="number">2</span>)下标位置为<span class="number">1</span>，</span><br><span class="line">			   ② 当cur == <span class="number">1</span>时，返回(k - <span class="number">1</span>, <span class="number">2</span>)，也就是右上角的值</span><br><span class="line">			   ③ 当cur == N时，返回(k - <span class="number">1</span>, N - <span class="number">1</span>)， 也就是返回左上角的值</span><br><span class="line">			   ④ 其余中间值，返回(k-<span class="number">1</span>, cur - <span class="number">1</span>) + (k-<span class="number">1</span>, cur + <span class="number">1</span>)，也就是左上角和右上角的值相加</span><br><span class="line">			   所以问号的值等于<span class="number">1</span> + <span class="number">3</span> = <span class="number">4</span>，返回<span class="number">4</span></span><br><span class="line">动态规划就是数组+递归，总结出规律即可。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>题二：</strong></p>
<blockquote>
<p>原题：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/coin-change/">https://leetcode.cn/problems/coin-change/</a></p>
<p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无。</p>
<p>比如amount = {2,7,3,2,2,2,2,3,5}，coins = 8. 最小硬币数2（3+5）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一（递归）：最简单的递归方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bestCoin</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> aim, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (aim &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (aim == <span class="number">0</span>) &#123;</span><br><span class="line">        res = Math.min(count, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这种也相当于要或者不要的递归方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        bestCoin(arr, aim - arr[i], count + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(coins.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bestCoin(coins,amount,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有任何一种硬币组合能组成总金额，返回 -1。</span></span><br><span class="line">    <span class="keyword">if</span>(res == Integer.MAX_VALUE)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解法二(记忆化搜索）：memo[n]用来保存剩余钱数需要多少个硬币，-1时代表无法满足</span></span><br><span class="line"><span class="keyword">int</span>[] memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(coins.length == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    memo = <span class="keyword">new</span> <span class="keyword">int</span>[amount];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findWay(coins,amount);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// memo[n] 表示钱币n可以被换取的最少的硬币数，不能换取就为-1</span></span><br><span class="line">    <span class="comment">// findWay函数的目的是为了找到 amount数量的零钱可以兑换的最少硬币数量，返回其值int</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findWay</span><span class="params">(<span class="keyword">int</span>[] coins,<span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(amount &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(amount == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记忆化的处理，memo[n]用赋予了值，就不用继续下面的循环</span></span><br><span class="line">    <span class="comment">// 直接的返回memo[n] 的最优值</span></span><br><span class="line">    <span class="keyword">if</span>(memo[amount-<span class="number">1</span>] != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> memo[amount-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; coins.length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> res = findWay(coins,amount-coins[i]);</span><br><span class="line">        <span class="keyword">if</span>(res &gt;= <span class="number">0</span> &amp;&amp; res &lt; min)&#123;</span><br><span class="line">            min = res + <span class="number">1</span>; <span class="comment">// 加1，是为了加上得到res结果的那个步骤中，兑换的一个硬币</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    memo[amount-<span class="number">1</span>] = (min == Integer.MAX_VALUE ? -<span class="number">1</span> : min);</span><br><span class="line">    <span class="keyword">return</span> memo[amount-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法三（动态规划）：https://blog.csdn.net/LL19880915/article/details/120292953</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>题三</strong></p>
<blockquote>
<p>给定数组arr，arr中所有的值都为正数，且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。</p>
</blockquote>
<blockquote>
<p>例如<br>arr = [5, 10, 25, 1], aim = 0，返回0<br>arr = [5, 10, 25, 1], aim = 15，返回6<br>arr = [3, 5]，aim = 2，返回0</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line">对于arr种某一面值，假设数组中第一个数据，如果不选中，那么求后面的所有面额组成aim的所有可能。</span><br><span class="line">如果选中一张，aim减去这张面额，然后递归求解剩余面额解决剩余aim的问题</span><br><span class="line">如果选中两张，aim就减去两张这样的面额，然后递归求解剩余面额解决剩余aim的问题。</span><br><span class="line">如果选中三张总面额超出aim，则当前面额遍历结束，进入下一层</span><br><span class="line">递归结束条件： 如果面额数组arr遍历结束了，且当前的aim==<span class="number">0</span>,则返回<span class="number">1</span>；</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinAimCount</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> aim, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> aim == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;	</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; arr[index] * i &lt;= aim; i++) &#123;</span><br><span class="line">            res += coinAimCount(arr, aim - arr[index] * i, index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态规划</span></span><br><span class="line">两个可变参数：二维dp[arr.length + <span class="number">1</span>][aim + <span class="number">1</span>]</span><br><span class="line">arr = [<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>], aim = <span class="number">10</span></span><br><span class="line">* 我们要取（<span class="number">0</span>，<span class="number">10</span>）的数就是我们的结果</span><br><span class="line">① index == length且aim==<span class="number">0</span>时，为<span class="number">1</span>，其余为</span><br><span class="line">③ 假设我们要取中间值（<span class="number">2</span>，<span class="number">5</span>）的位置，根据递归分析，Ⅰ当为<span class="number">0</span>张时，index + <span class="number">1</span>，往下走，来到（<span class="number">3</span>，<span class="number">5</span>），此时金额还是<span class="number">5</span> - arr[<span class="number">2</span>] * <span class="number">0</span>，aim还是<span class="number">5</span>，不变。Ⅱ当取一张时，<span class="number">5</span> - arr[<span class="number">2</span>] * <span class="number">1</span>, aim变为<span class="number">4</span>，来到(<span class="number">3</span>，<span class="number">4</span>)，Ⅲ当取两张的时候<span class="number">5</span> - arr[<span class="number">2</span>] * <span class="number">2</span>，aim变为<span class="number">3</span>，来到（<span class="number">3</span>，<span class="number">3</span>）位置..........</span><br><span class="line">这时我们发现规律，二维数组的中间值，取决于该位置下方左边所有的值。</span><br><span class="line">  <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span>                     ？</span><br><span class="line"><span class="number">1</span> </span><br><span class="line"><span class="number">2</span>           *       </span><br><span class="line"><span class="number">3</span> . .  .  . .</span><br><span class="line"><span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">coinAimCount2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index, <span class="keyword">int</span> aim)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>][aim + <span class="number">1</span>];</span><br><span class="line">        dp[arr.length][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= aim; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> zhang = <span class="number">0</span>; arr[index] * zhang &lt;= j; zhang++) &#123;</span><br><span class="line">                    res += dp[index + <span class="number">1</span>][j - arr[index] * zhang];</span><br><span class="line">                &#125;</span><br><span class="line">                dp[index][j] = res;</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为我们想知道aim = X, index = 0位置的值</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][aim];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>题四</strong></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a></p>
<p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
</blockquote>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     max = Math.max(max, process(nums, i));</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return max;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dp[nums.length] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i + <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = nums[i] + dp[i + <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            max =  Math.max(max, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = process(nums, index + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[index] + (count &gt; <span class="number">0</span> ? count : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><blockquote>
<p>有序表包括了：<strong>BSF、AVL、SB、RBT、跳表</strong></p>
</blockquote>
<h4 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h4><blockquote>
<p>跳表相对于传统的有序表，提高了很大的效率。他的节点主要有key、value和一个节点集合（多链表）构成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SkipListNode&lt;K extends Comparable&lt;K&gt;, V&gt;&#123;</span><br><span class="line">	K key,</span><br><span class="line">	V value,</span><br><span class="line">	ArrayList&lt;SkipListNode&lt;K,V&gt;&gt; nextNodes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>会有一个默认的节点，默认节点的默认有一条指向外头的指针。<strong>①初始</strong> 当刚开始有数据时，比如3，他会让这个节点随机产生链表数，比如产生了3条，因为默认节点只有一条，所以，会先让默认节点扩充到3条，然后让这三条全部指向新进来的节点3。<strong>② 新数据插入</strong>，当有新数据进来时，如70，他会让这个70节点随机产生链表数，比如说产生了2条，他会先去默认节点查看有没有大于2条链表的，大于则不会让默认节点产生新的链表数，此时发现5层的，有20节点，比70小，他直接跳到20节点，省去前面3、5、15节点，提高了效率，然后层数继续往下，此时发现4层，有50节点，比70小，省去了30、40节点，层数再往下的时候发现是100了，这时候就把70节点放入到50和100的中间，并且50的两条链表指向70，70的两条链表指向100。<strong>③删除</strong>，删除的时候需要先查找，也是感觉层数从上往下找，找到了就把链表重新指向，原来要删的元素制空即可。下图分别是插入前，插入后</p>
</blockquote>
<p><strong>插入前</strong>：</p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/27/e94cb01f79d74083.png" class="lazyload"></p>
<p><strong>插入后：</strong></p>
<p><img data-src="https://s3.bmp.ovh/imgs/2023/03/27/b92c22216cec6848.png" class="lazyload"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">覃烽</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">http://example.com/2023/06/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">LuckyFeng的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2023/06/11/%E7%BD%91%E7%BB%9C/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>网络</span></div></a></div><div class="next-post pull_right"><a href="/2023/06/11/RocketMq/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>RocketMq</span></div></a></div></nav></div></div><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2023 By 覃烽</div><div class="framework-info"><span>驱动 </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script id="ribbon_piao" mobile="true" src="/js/third-party/piao.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/click_heart.js"></script></body></html>